title,abstract
Short communication - Improving feature location accuracy via paragraph vector tuning,"AbstractContextFeature location techniques are still not highly accurate despite advances in the field.ObjectiveThis paper aims at investigating the impact of applying different tunings to paragraph vector to the feature location problem. It evaluates the influence of different artificial neural network (ANN) configurations for learning rate and negative sampling loss function in paragraph vectors training.MethodThe suggested weight configuration relies on the search for an adequate ANN learning rate and an adequate calibration of negative sampling skip-gram mode of the Doc2vec (DV) algorithm. A dataset with 633 feature descriptions, extracted from six open-source Java projects, organized within method granularity, is used for the empirical assessment.ResultsOur results suggest that feature location techniques benefit from the use of paragraph vector with systematic tuning. We show that an adequate update policy for ANN weights can increase feature location accuracy. An adequate calibration for negative sampling also improved accuracy. We got it with no default values of negative sampling pointed by literature. Moreover, an ensemble of learning rate policies and the use of a tuned DV negative sampling option had overcome state-of-the-art approaches.ConclusionsWe show evidence of a relationship between hyper-parameter settings and accuracy gain. Modern paragraph vector approaches require adequate calibration to produce better results, and we have improved the accuracy of feature location process with proper tuning."
Review article - Software process line as an approach to support software process reuse: A systematic literature review,"AbstractContextSoftware Process Line (SPrL) aims at providing a systematic reuse technique to support reuse experiences and knowledge in the definition of software processes for new projects thus contributing to reduce effort and costs and to achieve improvements in quality. Although the research body in SPrL is expanding, it is still an immature area with results offering an overall view scattered with no consensus.ObjectiveThe goal of this work is to identify existing approaches for developing, using, managing and visualizing the evolution of SPrLs and to characterize their support, especially during the development of reusable process family artefacts, including an overview of existing SPrL supporting tools in their multiple stages; to analyse variability management and component-based aspects in SPrL; and, finally, to list practical examples and conducted evaluations. This research aims at reaching a broader and more consistent view of the research area and to provide perspectives and gaps for future research.MethodWe performed a systematic literature review according to well-established guidelines set. We used tools to partially support the process, which relies on a six-member research team.ResultsWe report on 49 primary studies that deal mostly with conceptual or theoretical proposals and the domain engineering stage. Years 2014, 2015, and 2018 yielded the largest number of articles. This can indicate SPrL as a recent research theme and one that attracts ever-increasing interest.ConclusionAlthough this research area is growing, there is still a lack of practical experiences and approaches for actual applications or project-specific process derivations and decision-making support. The concept of an integrated reuse infrastructure is less discussed and explored; and the development of integrated tools to support all reuse stages is not fully addressed. Other topics for future research are discussed throughout the paper with gaps pointed as opportunities for improvements in the area."
Research article - Impact of the conceptual model's representation format on identifying and understanding user stories,"AbstractContextEliciting user stories is a major challenge for agile development approaches. Conceptual models are used to support the identification of user stories and increase their understanding. In many companies, existing model documentation stored as either use cases or BPMN models is available. However, these two types of business process models might not be equally effective for elicitation tasks due to their formats.ObjectiveWe address the effectiveness of different elicitation tasks when supported either with visual or textual conceptual model. Since the agile literature shows little attention to reusing existing BPMN documentation, we propose several hypotheses to compare it to the use of textual use case models.MethodWe conducted an experiment to compare the effectiveness of the two business process formats: textual use cases and visual BPMN models. We studied their effects on three elicitation tasks: identifying user stories and understanding their execution-order and integration dependencies.ResultsThe subjects better understood execution-order dependencies when visual input in the form of BPMN models was provided. The performance of the other two tasks showed no statistical differences.ConclusionWe addressed an important problem of user story elicitation: which informationally equivalent model (visual BPMN or textual use case) is more effective when identifying and understanding user stories."
Research article - Assessing the effectiveness of goal-oriented modeling languages: A family of experiments,"AbstractContextSeveral goal-oriented languages focus on modeling stakeholders’ objectives, interests or wishes. However, these languages can be used for various purposes (e.g., exploring system solutions or evaluating alternatives), and there are few guidelines on how to use these models downstream to the software requirements and design artifacts. Moreover, little attention has been paid to the empirical evaluation of this kind of languages. In a previous work, we proposed value@GRL as a specialization of the Goal Requirements Language (GRL) to specify stakeholders’ goals when dealing with early requirements in the context of incremental software development.ObjectiveThis paper compares the value@GRL language with the i* language, with respect to the quality of goal models, the participants’ modeling time and productivity when creating the models, and their perceptions regarding ease of use and usefulness.MethodA family of experiments was carried out with 184 students and practitioners in which the participants were asked to specify a goal model using each of the languages. The participants also filled in a questionnaire that allowed us to assess their perceptions.ResultsThe results of the individual experiments and the meta-analysis indicate that the quality of goal models obtained with value@GRL is higher than that of i*, but that the participants required less time to create the goal models when using i*. The results also show that the participants perceived value@GRL to be easier to use and more useful than i* in at least two experiments of the family.Conclusionsvalue@GRL makes it possible to obtain goal models with good quality when compared to i*, which is one of the most frequently used goal-oriented modeling languages. It can, therefore, be considered as a promising emerging approach in this area. Several insights emerged from the study and opportunities for improving both languages are outlined."
Research article - Package-Level stability evaluation of object-oriented systems,"AbstractContextSoftware stability is an important object-oriented design characteristic that contributes to the maintainability quality attribute. Software stability quantifies a given systems sensitivity to change between different versions. Stable software tends to reduce the maintenance effort. Assessing software stability during the object-oriented design phase is one of the measures to obtain maintainable software. To determine software stability, there are several metrics at the architecture, system and class levels, but few studies have investigated stability at the package level.ObjectiveIn this paper, we propose a new package stability metrics (PSM) based on the notion of change between package contents, intra-package connections and inter-package connections.MethodWe validate the PSM theoretically and empirically. The theoretical validation is based on a study of the mathematical properties of the metrics. The empirical validation is carried out using five open source software programs and we also present a comparison with comparable existing stability metrics packages. For the empirical validation, we perform correlation analysis, principal component analysis and prediction analysis.ResultsCorrelation analysis shows that our proposed metrics provides a better indication of package stability than the existing stability metrics and they are negatively correlated with the maintenance effort. Principal component analysis shows that the proposed metrics captures new dimensions of package stability and helps to increase the maintenance prediction accuracy.ConclusionWe found there was a negative correlation between our metric and maintenance effort. We also found a positive correlation between the existing package stability metrics which are based on changes in lines of code and class names."
Research article - Finding key classes in object-oriented software systems by techniques based on static analysis,"AbstractContextSoftware maintenance is burdened by program comprehension activities which consume a big part of project resources. Program comprehension is difficult because the code to be analyzed is very large and the documentation may not be well structured to help navigating through the code.ObjectiveTools should support the early stages of program comprehension. Our goal is to build tools that analyze the code and filter this large amount of information such that only the most important information is presented to the software maintenance team. In the case of object-oriented systems, finding the important information means finding the most important classes, also called the key classes of the system.MethodIn this work, we formulate and explore several hypotheses regarding which are the class attributes that characterize important classes. By class attributes, we understand here different metrics that quantify properties of the class such as its connections and relationships with other classes. All the necessary input data for computing class attributes are extracted from code by static analysis. We experimentally investigate which attributes are best suited to rank classes according to their importance, doing an extensive empirical study on fifteen software systems.ResultAttributes from the categories of direct connections and network centrality are the best for finding key classes. We identified three class attributes which are best as class ranking criteria: PR-U2-W and CONN-TOTAL-W when the target set of key classes is small and CONN-TOTAL when the target set has a large and variable size. We show that the method of ranking classes based on these attributes outperforms known related work approaches of finding key classes.ConclusionsOur method allows us to build easy-to-use fully automatic tools which find almost instantly the key classes of a software system starting from its code."
