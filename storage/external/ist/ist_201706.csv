title,abstract
"Research article - A study on the statistical convertibility of IFPUG Function Point, COSMIC Function Point and Simple Function Point","AbstractBackground Several functional size measurement methods have been proposed. A few ones –like IFPUG and COSMIC methods– are widely used, while others –like Simple Function Points method– are interesting new proposals, which promise to deliver functional size measures via a faster and cheaper measurement process.Objectives Since all functional size measurement methods address the measurement of the same property of software (namely, the size of functional specifications), it is expected that measures provided in a given measurement unit can be converted into a different measurement unit. In this paper, convertibility of IFPUG Function Points, COSMIC Function Points, and Simple Function Points is studied.Method Convertibility is analyzed statistically via regression techniques. Seven datasets, each one containing measures of a set of software applications expressed in IFPUG Function Points, COSMIC Function Points and Simple Function Points, were analyzed. The components of functional size measures (usually known as Base Functional Components) were also involved in the analysis.Results All the analyzed measures appear well correlated to each other. Statistically significant quantitative models were found for all the combinations of measures, for all the analyzed datasets. Several models involving Base Functional Components were found as well.Conclusions From a practical point of view, the paper shows that converting measures from a given functional size unit into another one is viable. The magnitude of the conversion errors is reported, so that practitioners can evaluate if the expected conversion error is acceptable for their specific purposes. From a conceptual point of view, the paper shows that Base Functional Components of a given method can be used to estimate measures expressed in a different measurement unit: this seems to imply that different functional size measurement methods are ‘structurally’ strongly correlated."
Research article - Handling constraints in combinatorial interaction testing in the presence of multi objective particle swarm and multithreading,"AbstractContextCombinatorial testing strategies have lately received a lot of attention as a result of their diverse applications. In its simple form, a combinatorial strategy can reduce several input parameters (configurations) of a system into a small set based on their interaction (or combination). In practice, the input configurations of software systems are subjected to constraints, especially in case of highly configurable systems. To implement this feature within a strategy, many difficulties arise for construction. While there are many combinatorial interaction testing strategies nowadays, few of them support constraints.ObjectiveThis paper presents a new strategy, to construct combinatorial interaction test suites in the presence of constraints.MethodThe design and algorithms are provided in detail. To overcome the multi-judgement criteria for an optimal solution, the multi-objective particle swarm optimisation and multithreading are used. The strategy and its associated algorithms are evaluated extensively using different benchmarks and comparisons.ResultsOur results are promising as the evaluation results showed the efficiency and performance of each algorithm in the strategy. The benchmarking results also showed that the strategy can generate constrained test suites efficiently as compared to state-of-the-art strategies.ConclusionThe proposed strategy can form a new way for constructing of constrained combinatorial interaction test suites. The strategy can form a new and effective base for future implementations."
Research article - Towards an understanding of change types in bug fixing code,"AbstractContextAs developing high quality software becomes increasingly challenging because of the explosive growth of scale and complexity, bugs become inevitable in software systems. The knowledge of bugs will naturally guide software development and hence improve software quality. As changes in bug fixing code provide essential insights into the original bugs, analyzing change types is an intuitive and effective way to understand the characteristics of bugs.ObjectiveIn this work, we conduct a thorough empirical study to investigate the characteristics of change types in bug fixing code.MethodWe first propose a new change classification scheme with 5 change types and 9 change subtypes. We then develop an automatic classification tool CTforC to categorize changes. To gain deeper insights into change types, we perform our empirical study based on three questions from three perspectives, i.e. across project, across domain and across version.ResultsBased on 17 versions of 11 systems with thousands of faulty functions, we find that: (1) across project: the frequencies of change subtypes are significantly similar across most studied projects; interface related code changes are the most frequent bug-fixing changes (74.6% on average); most of faulty functions (65.2% on average) in studied projects are finally fixed by only one or two change subtypes; function call statements are likely to be changed together with assignment statements or branch statements; (2) across domain: the frequencies of change subtypes share similar trends across studied domains; changes on function call, assignment, and branch statements are often the three most frequent changes in studied domains; and (3) across version: change subtypes occur with similar frequencies across studied versions, and the most common subtype pairs tend to be same.ConclusionOur experimental results improve the understanding of changes in bug fixing code and hence the understanding of the characteristics of bugs."
Research article - Building reliable and maintainable Dynamic Software Product Lines: An investigation in the Body Sensor Network domain,"AbstractContext: Dependability is a key requirement, especially in safety-critical applications. Many of these applications have changing context and configurations at runtime to achieve functional and quality goals and can be realized as Dynamic Software Product Lines (DSPLs). DSPL constitutes an emerging but promising research area. Nevertheless, ensuring dependability in DSPLs remains insufficiently explored, especially in terms of reliability and maintainability. This compromises quality assurance and applicability of DSPLs in safety-critical domains, such as Body Sensor Network (BSN).Objective: To address this issue, we propose an approach to developing reliable and maintainable DSPLs in the context of the BSN domain.Method: Adaptation plans are instances of a Domain Specific Language (DSL) describing reliability goals and adaptability at runtime. These instances are automatically checked for reliability goal satisfiability before being deployed and interpreted at runtime to provide more suitable adaptation goals complying with evolving needs perceived by a domain specialist.Results: The approach is evaluated in the BSN domain. Results show that reliability and maintainability could be provided with execution and reconfiguration times of around 30 ms, notification and adaptation plan update time over the network around 5 s, and space consumption around 5  MB.Conclusion: The method is feasible at reasonable cost. The incurred benefits are reliable vital signal monitoring for the patient—thus providing early detection of serious health issues and the possibility of proactive treatment—and a maintainable infrastructure allowing medical DSL instance update to suit the needs of the domain specialist and ultimately of the patient."
Research article - Software teams and their knowledge networks in large-scale software development,"AbstractContextLarge software development projects involve multiple interconnected teams, often spread around the world, developing complex products for a growing number of customers and users. Succeeding with large-scale software development requires access to an enormous amount of knowledge and skills. Since neither individuals nor teams can possibly possess all the needed expertise, the resource availability in a team's knowledge network, also known as social capital, and effective knowledge coordination become paramount.ObjectiveIn this paper, we explore the role of social capital in terms of knowledge networks and networking behavior in large-scale software development projects.MethodWe conducted a multi-case study in two organizations, Ericsson and ABB, with software development teams as embedded units of analysis. We organized focus groups with ten software teams and surveyed 61 members from these teams to characterize and visualize the teams’ knowledge networks. To complement the team perspective, we conducted individual interviews with representatives of supporting and coordination roles. Based on survey data, data obtained from focus groups, and individual interviews, we compared the different network characteristics and mechanisms that support knowledge networks. We used social network analysis to construct the team networks, thematic coding to identify network characteristics and context factors, and tabular summaries to identify the trends.ResultsOur findings indicate that social capital and networking are essential for both novice and mature teams when solving complex, unfamiliar, or interdependent tasks. Network size and networking behavior depend on company experience, employee turnover, team culture, need for networking, and organizational support. A number of mechanisms can support the development of knowledge networks and social capital, for example, introduction of formal technical experts, facilitation of communities of practice and adequate communication infrastructure.ConclusionsOur study emphasizes the importance of social capital and knowledge networks. Therefore, we suggest that, along with investments into training programs, software companies should also cultivate a networking culture to strengthen their social capital, a known driver of better performance."
Review article - Systematic literature review on the impacts of agile release engineering practices,"AbstractContextAgile release engineering (ARE) practices are designed to deliver software faster and cheaper to end users; hence, claims of such impacts should be validated by rigorous and relevant empirical studies.ObjectiveThe study objective was to analyze both direct and indirect impacts of ARE practices as well as to determine how they have been empirically studied.MethodThe study applied the systematic literature review research method. ARE practices were identified in empirical studies by searching articles for “rapid release,” “continuous integration,” “continuous delivery,” and “continuous deployment.” We systematically analyzed 619 articles and selected 71 primary studies for deeper investigation. The impacts of ARE practices were analyzed from three viewpoints: impacts associated with adoption of the practice, prevalence of the practice, and success of software development.ResultsThe results indicated that ARE practices can create shorter lead times and better communication within and between development teams. However, challenges and drawbacks were also found in change management, software quality assurance, and stakeholder acceptance. The analysis revealed that 33 out of 71 primary studies were casual experience reports that had neither an explicit research method nor a data collection approach specified, and 23 out of 38 empirical studies applied qualitative methods, such as interviews, among practitioners. Additionally, 12 studies applied quantitative methods, such as mining of software repositories. Only three empirical studies combined these research approaches.ConclusionARE practices can contribute to improved efficiency of the development process. Moreover, release stakeholders can develop a better understanding of the software project's status. Future empirical studies should consider the comprehensive reporting of the context and how the practice is implemented instead of merely referring to usage of the practice. In addition, different stakeholder points of view, such as customer perceptions regarding ARE practices, still clearly require further research."
Research article - An examination of personality traits and how they impact on software development teams,"AbstractContext: Research has shown that a significant number of software projects fail due to social issues such as team or personality conflicts. However, only a limited number of empirical studies have been undertaken to understand the impact of individuals’ personalities on software team configurations. These studies suffer from an important limitation as they lack a systematic and rigorous method to relate personality traits of software practitioners and software team structures.Objective: Based on an interactive personality profiling approach, the goal of this study is to reveal the personality traits of software practitioners with an aim to explore effective software team structures.Method: To explore the importance of individuals’ personalities on software teams, we employed a two-step empirical approach. Firstly, to assess the personality traits of software practitioners, we developed a context-specific survey instrument, which was conducted on 216 participants from a middle-sized software company. Secondly, we propose a novel team personality illustration method to visualize team structures.Results: Study results indicated that effective team structures support teams with higher emotional stability, agreeableness, extroversion, and conscientiousness personality traits.Conclusion: Furthermore, empirical results of the current study show that extroversion trait was more predominant than previously suggested in the literature, which was especially more observable among agile software development teams."
