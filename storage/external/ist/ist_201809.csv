title,abstract
Research article - The use of artificial neural networks for extracting actions and actors from requirements document,"AbstractContextThe automatic extraction of actors and actions (i.e., use cases) of a system from natural language-based requirement descriptions, is considered a common problem in requirements analysis. Numerous techniques have been used to resolve this problem. Examples include rule-based (e.g., inference), keywords, query (e.g., bi-grams), library maintenance, semantic business vocabularies, and rules. The question remains: can combination of natural language processing (NLP) and artificial neural networks (ANNs) perform this job successfully and effectively?ObjectiveThis paper proposes a new approach to automatically identify actors and actions in a natural language-based requirements’ description of a system. Included are descriptions of how NLP plays an important role in extracting actors and actions, and how ANNs can be used to provide definitive identification.MethodWe used an NLP parser with a general architecture for text engineering, producing lexicons, syntaxes, and semantic analyses. An ANN was developed using five different use cases, producing different results due to their complexity and linguistic formation.ResultsBinomial classification accuracy techniques were used to evaluate the effectiveness of this approach. Based on the five use cases, the results were 17–63% for precision, 5–6100% for recall, and 29–71% for F-measure.ConclusionWe successfully used a combination of NLP and ANN artificial intelligence techniques to reveal specific domain semantics found in a software requirements specification. An Intelligent Technique for Requirements Engineering (IT4RE) was developed to provide a semi-automated approach, classified as Intelligent Computer Aided Software Engineering (I-CASE)."
Research article - Specification and automatic checking of architecture constraints on object oriented programs,"AbstractContext: Architecture constraints are specifications of conditions to which an architecture model must adhere in order to satisfy an architecture decision imposed by a given design principle. These constraints can be specified with predicate languages like OCL at design time and checked on design artifacts.Objective: Many works in the literature studied the importance of checking these constraints to guarantee quality on design models, and to prevent technical debt and maintenance difficulties. In this paper, we propose a process whose ultimate goal is to enable the checking of these constraints in the implementation stage.Method: The proposed process takes as input a textual specification of an architecture constraint specified at design stage. It translates this specification into meta-programs and then it uses them with aspect-oriented programming to check constraints at the implementation stage and at run-time on object-oriented programs.Results: We experimented an implementation of this process on a set of 12 architecture constraints. The results of this experimentation showed that our process is able to statically and dynamically detect architecture constraint violations on toy object-oriented applications, but also on real-world ones.Conclusion: The automatic checking of architecture constraints is important at source code level and at runtime. It avoids the disappearance of architecture decision knowledge in implementation artifacts, and facilitates later their maintenance."
Research article - Characterizing mobile apps from a source and test code viewpoint,"AbstractContext: while the mobile computing market has expanded and become critical, the amount and complexity of mobile apps have also increased. To assure reliability, these apps require software engineering methods, mainly verification, validation, and testing. However, mobile app testing is a challenging activity due to the diversity and limitations found in mobile devices. Thus, it would be interesting to characterize mobile apps in hopes of assisting in the definition of more efficient and effective testing approaches. Objective: this paper aims to identify and quantify the specific characteristics of mobile apps so that testers can draw from this knowledge and tailor software testing activities to mobile apps. We investigate the presence of automated tests, adopted frameworks, external connectivity, graphical user interface (GUI) elements, sensors, and different system configurations. Method: we developed a tool to support the automatic extraction of characteristics from Android apps. We conducted an empirical study with a sample of 663 open source mobile apps. Results: we found that one third of the projects perform automated testing. The frameworks used in these projects can be divided into three groups: unit testing, GUI testing, and mocking. There is a medium correlation between project size and test presence. Specific features of mobile apps (connectivity, GUI, sensors, and multiple configurations) are present in the projects, however, they are fully covered by tests. Conclusion: automated tests are still not developed in a systematic way. Interestingly, measures of app popularity (number of downloads and rating) do not seem to be correlated with the presence of tests. However, the results show a correlation of the project size and more critical domains with the existence of automated tests. Although challenges such as connectivity, sensors, and multiple configurations are present in the examined apps, only one tool has been identified to support the testing of these challenges."
Research article - Group decision-making in software architecture: A study on industrial practices,"AbstractContextA Software Architecture results from a comprehensive process in which several stakeholders deliberate upon the key requirements, issues, solutions and make architectural design decisions. Literature shows that most architectural decisions, in practice, are made in groups. Still, there is a limited understanding of industrial group decision-making practices in software architecture and the challenges that software architecture groups face.ObjectiveOur study, by drawing inspiration from group decision-making theories and models, aims at understanding (i) Existing decision-making practices in software architecture groups (ii) the comparison between practice and theory, (iii) the challenges that the groups face, and (iv) the satisfaction of group members with various aspects of Group Decision Making.MethodThe study has been conducted through a questionnaire-based survey. 35 practitioners participated in this survey and the responses were analyzed qualitative and quantitatively.ResultsThe analysis of individual responses reveal that software architecture groups (composed, on average, of 3–5 co-located or dispersed members) adopt a discussion based approach while evaluating alternatives, thereby lacking a structured way of decision-making. In these groups, despite the involvement of group members in the discussions, the final decision is made by an individual of authority. Not only is structured decision-making less common, the usage of dedicated software tools for decision-making too is rare. These groups face challenges that are indicative of Groupthink and Group Polarization. Group members feel that quantity of alternatives generated during discussions and tool availability are below satisfactory and they have low satisfaction with the tool support available.ConclusionThis study has helped us develop an understanding of software architecture groups, their decision-making practices and challenges faced together with the satisfaction of group members. What the industry needs is integration of group decision-making principles into software architecture decision-making and design of decision-making tools that assist the architecture groups."
