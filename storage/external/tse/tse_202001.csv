title,abstract
Need for Sleep: The Impact of a Night of Sleep Deprivation on Novice Developers’ Performance,"Abstract We present a quasi-experiment to investigate whether, and to what extent, sleep deprivation impacts the performance of novice software developers using the agile practice of test-first development (TFD). We recruited 45 undergraduates, and asked them to tackle a programming task. Among the participants, 23 agreed to stay awake the night before carrying out the task, while 22 slept normally. We analyzed the quality (i.e., the functional correctness) of the implementations delivered by the participants in both groups, their engagement in writing source code (i.e., the amount of activities performed in the IDE while tackling the programming task) and ability to apply TFD (i.e., the extent to which a participant is able to apply this practice). By comparing the two groups of participants, we found that a single night of sleep deprivation leads to a reduction of 50 percent in the quality of the implementations. There is notable evidence that the developers' engagement and their prowess to apply TFD are negatively impacted. Our results also show that sleep-deprived developers make more fixes to syntactic mistakes in the source code. We conclude that sleep deprivation has possibly disruptive effects on software development activities. The results open opportunities for improving developers' performance by integrating the study of sleep with other psycho-physiological factors in which the software engineering research community has recently taken an interest in.Keywords Computer Aided Instruction, Computer Science Education, Sleep, Software Engineering, Source Code, Sleep Deprivation, Software Development Activities, Novice Software Developers, TFD, Programming Task, Sleep Deprived Developers, Sleep, Software, Task Analysis, Biomedical Monitoring, Software Engineering, Programming, Functional Magnetic Resonance Imaging, Sleep Deprivation, Psycho Physiological Factors, Test First Development"
Automatically Categorizing Software Technologies,"Abstract Informal language and the absence of a standard taxonomy for software technologies make it difficult to reliably analyze technology trends on discussion forums and other on-line venues. We propose an automated approach called Witt for the categorization of software technologies (an expanded version of the hypernym discovery problem). Witt takes as input a phrase describing a software technology or concept and returns a general category that describes it (e.g., integrated development environment), along with attributes that further qualify it (commercial, php, etc.). By extension, the approach enables the dynamic creation of lists of all technologies of a given type (e.g., web application frameworks). Our approach relies on Stack Overflow and Wikipedia, and involves numerous original domain adaptations and a new solution to the problem of normalizing automatically-detected hypernyms. We compared Witt with six independent taxonomy tools and found that, when applied to software terms, Witt demonstrated better coverage than all evaluated alternative solutions, without a corresponding degradation in false positive rate.Keywords Encyclopaedias, Public Domain Software, Web Sites, Witt, Software Terms, Software Technology, Hypernym Discovery Problem, Taxonomy Tools, Stack Overflow, Wikipedia, Software Technologies Categorization, Online Venues, Forums, Software, Encyclopedias, Electronic Publishing, Internet, Taxonomy, Tools, Taxonomy, Information Retrieval, Natural Language Processing, Wikipedia, Tagging"
Use and Misuse of Continuous Integration Features: An Empirical Study of Projects That (Mis)Use Travis CI,"Abstract Continuous Integration (CI) is a popular practice where software systems are automatically compiled and tested as changes appear in the version control system of a project. Like other software artifacts, CI specifications require maintenance effort. Although there are several service providers like TRAVIS CI offering various CI features, it is unclear which features are being (mis)used. In this paper, we present a study of feature use and misuse in 9,312 open source systems that use TRAVIS CI. Analysis of the features that are adopted by projects reveals that explicit deployment code is rare-48.16 percent of the studied TRAVIS CI specification code is instead associated with configuring job processing nodes. To analyze feature misuse, we propose HANSEL-an anti-pattern detection tool for TRAVIS CI specifications. We define four anti-patterns and HANSEL detects anti-patterns in the TRAVIS CI specifications of 894 projects in the corpus (9.60 percent), and achieves a recall of 82.76 percent in a sample of 100 projects. Furthermore, we propose GRETEL-an anti-pattern removal tool for TRAVIS CI specifications, which can remove 69.60 percent of the most frequently occurring antipattern automatically. Using GRETEL, we have produced 36 accepted pull requests that remove TRAVIS CI anti-patterns automatically.Keywords Object Oriented Programming, Program Testing, Software Development Management, Software Maintenance, Software Metrics, Software Performance Evaluation, Software Quality, Continuous Integration Features, Software Systems, Version Control System, CI Features, Studied TRAVIS CI Specification Code, Anti Pattern Detection Tool, CI Anti Patterns, Open Source Systems, Efficiency 48 16 Percent, Efficiency 9 6 Percent, Efficiency 69 6 Percent, Object Oriented Programming, Software Development Management, Software Maintenance, Software Quality, Software Performance, Continuous Integration, Anti Patterns, Mining Software Repositories"
Incentivizing Deep Fixes in Software Economies,"Abstract An important question in a software economy is how to incentivize deep rather than shallow fixes. A deep fix corrects the root cause of a bug instead of suppressing the symptoms. This paper initiates the study of the problem of incentive design for open workflows in fixing code. We model the dynamics of the software ecosystem and introduce subsumption mechanisms. These mechanisms only make use of externally observable information in determining payments and promote competition between workers. We use a mean field equilibrium methodology to evaluate the performance of these mechanisms, demonstrating in simulation that subsumption mechanisms perform robustly across various environment configurations and satisfy important criteria for market design.Keywords Game Theory, Socio Economic Effects, Software Development Management, Mean Field Equilibrium Methodology, Subsumption Mechanisms, Software Economy, Open Workflows, Software Ecosystem, Externally Observable Information, Computer Bugs, Task Analysis, Ecosystems, Open Source Software, Testing, Software Engineering, Market Design, Mean Field Equilibrium, Software Engineering, Payment Mechanisms"
"On the Understandability of Temporal Properties Formalized in Linear Temporal Logic, Property Specification Patterns and Event Processing Language","Abstract Temporal properties are important in a wide variety of domains for different purposes. For example, they can be used to avoid architectural drift in software engineering orto support the regulatory compliance of business processes. In this work, we study the understandability of three majortemporal property representations: (1) LinearTemporal Logic (LTL) is a formal and well-established logic that offers temporal operators to describe temporal properties; (2) Property Specification Patterns (PSP) are a collection of recurring temporal properties that abstract underlying formal and technical representations; (3) Event Processing Language (EPL) can be used for runtime monitoring of event streams using Complex Event Processing. We conducted two controlled experiments with 216 participants in total to study the understandability of those approaches using a completely randomized design with one alternative per experimental unit. We hypothesized that PSP, as a highly abstracting pattern language, is easier to understand than LTL and EPL, and that EPL, due to separation of concerns (as one or more queries can be used to explicitly define the truth value change that an observed event pattern causes), is easier to understand than LTL. We found evidence supporting our hypotheses which was statistically significant and reproducible.Keywords Formal Specification, Formal Verification, Pattern Recognition, Temporal Logic, Temporal Properties, Linear Temporal Logic, Business Processes, Complex Event Processing, Property Specification Patterns, Event Processing Language, Software Engineering, Software, Computer Science, Guidelines, Industries, Software Architecture, Cognition, Controlled Experiment, Understandability, Temporal Property, Linear Temporal Logic, Property Specification Patterns, Complex Event Processing, Event Processing Language"
A Multi-Study Investigation into Dead Code,"Abstract Dead code is a bad smell and it appears to be widespread in open-source and commercial software systems. Surprisingly, dead code has received very little empirical attention from the software engineering research community. In this paper, we present a multi-study investigation with an overarching goal to study, from the perspective of researchers and developers, when and why developers introduce dead code, howthey perceive and cope with it, and whether dead code is harmful. To this end, we conducted semi-structured interviews with software professionals and four experiments at the University of Basilicata and the College of William & Mary. The results suggest that it is worth studying dead code not only in the maintenance and evolution phases, where our results suggest that dead code is harmful, but also in the design and implementation phases. Our results motivate future work to develop techniques for detecting and removing dead code and suggest that developers should avoid this smell.Keywords Software Maintenance, Dead Code, Multistudy Investigation, Bad Smell, Commercial Software Systems, Open Source Software Systems, Software Systems, Maintenance Engineering, Software Engineering, Interviews, Tools, Open Source Software, Dead Code, Unreachable Code, Unused Code, Bad Smell, Empirical Investigation, Multi Study"
2019 Reviewers List,Abstract The publication offers a note of thanks and lists its reviewers.
Corrections to “Detecting Bugs by Discovering Expectations and Their Violations”,"Abstract In the above named work (ibid., vol. 45, no. 10, pp. 984–1001, Oct. 2019), the corresponding author should have been listed as Bin Liang. The footnote information is corrected here.     In [1], the corresponding author should have been listed as Bin Liang. The footnote information is corrected below. References  [1]P. Bian, B. Liang, Y. Zhang, C. Yang, W. Shi, and Y. Cai, “Detecting bugs by discovering expectations and their violations,” IEEE Trans. Softw. Eng ., vol. 45, no. 10, pp. 984–1001, Oct.2019.Keywords Computer Bugs, Computer Science, Software, Libraries"
2019 Index IEEE Transactions on Software Engineering Vol. 45,"Abstract This index covers all technical items - papers, correspondence, reviews, etc. - that appeared in this periodical during the year, and items from previous years that were commented upon or corrected in this year. Departments and other items may also be covered if they have been judged to have archival value. The Author Index contains the primary entry for each item, listed under the first author's name. The primary entry includes the co-authors' names, the title of the paper or other item, and its location, specified by the publication abbreviation, year, month, and inclusive pagination. The Subject Index contains entries describing the item under all appropriate subject headings, plus the first author's name, the publication abbreviation, month, and year, and inclusive pages. Note that the item title is found only under the primary entry in the Author Index."
