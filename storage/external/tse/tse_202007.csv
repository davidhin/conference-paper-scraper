title,abstract
Debugging Static Analysis,"Abstract Static analysis is increasingly used by companies and individual code developers to detect and fix bugs and security vulnerabilities. As programs grow more complex, the analyses have to support new code concepts, frameworks and libraries. However, static-analysis code itself is also prone to bugs. While more complex analyses are written and used in production systems every day, the cost of debugging and fixing them also increases tremendously. To understand the difficulties of debugging static analysis, we surveyed 115 static-analysis writers. From their responses, we determined the core requirements to build a debugger for static analyses, which revolve around two main issues: abstracting from both the analysis code and the code it analyses at the same time, and tracking the analysis internal state throughout both code bases. Most tools used by our survey participants lack the capabilities to address both issues. Focusing on those requirements, we introduce Visuflow, a debugging environment for static data-flow analysis. Visuflow features graph visualizations and custom breakpoints that enable users to view the state of an analysis at any time. In a user study on 20 static-analysis writers, Visuflow helped identify 25 and fix 50 percent more errors in the analysis code compared to the standard Eclipse debugging environment.Keywords Data Flow Analysis, Data Visualisation, Program Debugging, Program Diagnostics, Code Bases, Static Data Flow Analysis, Code Developers, Libraries, Static Analysis Code, Security Vulnerabilities, Graph Visualizations, Visuflow, Eclipse Debugging Environment, Debugging, Static Analysis, Tools, Computer Bugs, Standards, Writing, Encoding, Testing And Debugging, Program Analysis, Development Tools, Integrated Environments, Graphical Environments, Usability Testing"
Does Reviewer Recommendation Help Developers?,"Abstract Selecting reviewers for code changes is a critical step for an efficient code review process. Recent studies propose automated reviewer recommendation algorithms to support developers in this task. However, the evaluation of recommendation algorithms, when done apart from their target systems and users (i.e., code review tools and change authors), leaves out important aspects: perception of recommendations, influence of recommendations on human choices, and their effect on user experience. This study is the first to evaluate a reviewer recommender in vivo. We compare historical reviewers and recommendations for over 21,000 code reviews performed with a deployed recommender in a company environment and set out to measure the influence of recommendations on users' choices, along with other performance metrics. Having found no evidence of influence, we turn to the users of the recommender. Through interviews and a survey we find that, though perceived as relevant, reviewer recommendations rarely provide additional value for the respondents. We confirm this finding with a larger study at another company. The confirmation of this finding brings up a case for more user-centric approaches to designing and evaluating the recommenders. Finally, we investigate information needs of developers during reviewer selection and discuss promising directions for the next generation of reviewer recommendation tools. Preprint: https://doi.org/10.5281/zenodo.1404814.Keywords Recommender Systems, Review Sites, Software Engineering, Source Code Software, Code Review Tools, User Experience, Historical Reviewers, User Centric Approaches, Reviewer Selection, Reviewer Recommendation Tools, Code Review Process, Automated Reviewer Recommendation Algorithms, Tools, Recommender Systems, Companies, Measurement, Software, In Vivo, Software Engineering, Code Review, Reviewer Recommendation, Empirical Software Engineering"
Automatic and Accurate Expansion of Abbreviations in Parameters,"Keywords Information Retrieval, Software Maintenance, Formal Parameter, Parameter Abbreviations, IR Based Software Maintenance Activities, Abbreviation Expansion, Parameter Names, Program Comprehension, Dictionaries, Open Source Software, Syntactics, Approximation Algorithms, Software Maintenance, Indexes, Abbreviation, Expansion, Comprehension, Lexical Similarity, Quality, Information Retrieval"
Studying Bad Updates of Top Free-to-Download Apps in the Google Play Store,
Ensuring the Observability of Structural Test Obligations,"Keywords Program Testing, Public Domain Software, Structural Test Obligations, Test Adequacy Criteria, Test Creation, Statement Structure, Execution Path, Observability, Coverage Criteria, Boolean Expressions, Host Criterion, Path Condition, Industrial Systems, Program Structure, Open Source Systems, Mutation Detection, Onput Only Test Oracle, Observability, Test Pattern Generators, Monitoring, Sensitivity, Software, Complexity Theory, Software Testing, Automated Test Generation, Test Adequacy Criteria, Model Based Test Generation"
Finding Faster Configurations Using FLASH,"Abstract Finding good configurations of a software system is often challenging since the number of configuration options can be large. Software engineers often make poor choices about configuration or, even worse, they usually use a sub-optimal configuration in production, which leads to inadequate performance. To assist engineers in finding the better configuration, this article introduces Flash, a sequential model-based method that sequentially explores the configuration space by reflecting on the configurations evaluated so far to determine the next best configuration to explore. Flash scales up to software systems that defeat the prior state-of-the-art model-based methods in this area. Flash runs much faster than existing methods and can solve both single-objective and multi-objective optimization problems. The central insight of this article is to use the prior knowledge of the configuration space (gained from prior runs) to choose the next promising configuration. This strategy reduces the effort (i.e., number of measurements) required to find the better configuration. We evaluate Flash using 30 scenarios based on 7 software systems to demonstrate that Flash saves effort in 100 and 80 percent of cases in single-objective and multi-objective problems respectively by up to several orders of magnitude compared to state-of-the-art techniques.Keywords Evolutionary Computation, Optimisation, Search Problems, Software Fault Tolerance, Software Systems, Multiobjective Problems, Configuration Options, Software Engineers, Sub Optimal Configuration, Sequential Model Based Method, Configuration Space, Flash Scales, Multiobjective Optimization Problems, Software Systems, Optimization, Throughput, Storms, Task Analysis, Cloud Computing, Performance Prediction, Search Based SE, Configuration, Multi Objective Optimization, Sequential Model Based Methods"
