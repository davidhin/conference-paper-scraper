title,abstract
ARJA: Automated Repair of Java Programs via Multi-Objective Genetic Programming,"Abstract Automated program repair is the problem of automatically fixing bugs in programs in order to significantly reduce the debugging costs and improve the software quality. To address this problem, test-suite based repair techniques regard a given test suite as an oracle and modify the input buggy program to make the entire test suite pass. GenProg is well recognized as a prominent repair approach of this kind, which uses genetic programming (GP) to rearrange the statements already extant in the buggy program. However, recent empirical studies show that the performance of GenProg is not fully satisfactory, particularly for Java. In this paper, we propose ARJA, a new GP based repair approach for automated repair of Java programs. To be specific, we present a novel lower-granularity patch representation that properly decouples the search subspaces of likely-buggy locations, operation types and potential fix ingredients, enabling GP to explore the search space more effectively. Based on this new representation, we formulate automated program repair as a multi-objective search problem and use NSGA-II to look for simpler repairs. To reduce the computational effort and search space, we introduce a test filtering procedure that can speed up the fitness evaluation of GP and three types of rules that can be applied to avoid unnecessary manipulations of the code. Moreover, we also propose a type matching strategy that can create new potential fix ingredients by exploiting the syntactic patterns of existing statements. We conduct a large-scale empirical evaluation of ARJA along with its variants on both seeded bugs and real-world bugs in comparison with several state-of-the-art repair approaches. Our results verify the effectiveness and efficiency of the search mechanisms employed in ARJA and also show its superiority over the other approaches. In particular, compared to jGenProg (an implementation of GenProg for Java), an ARJA version fully following the redundancy assumption can generate a test-suite adequate patch for more than twice the number of bugs (from 27 to 59), and a correct patch for nearly four times of the number (from 5 to 18), on 224 real-world bugs considered in Defects4J. Furthermore, ARJA is able to correctly fix several real multi-location bugs that are hard to be repaired by most of the existing repair approaches.Keywords Genetic Algorithms, Java, Program Debugging, Program Testing, Search Problems, Software Maintenance, Software Quality, Sorting, ARJA, Multiobjective Genetic Programming, Automated Program Repair, Test Suite Based Repair Techniques, Buggy Program, Gen Prog, GP Based Repair Approach, Search Space, Multiobjective Search Problem, Real World Bugs, Multilocation Bugs, Test Filtering, Automated Repair Of Java Programs, Program Bugs, Debugging Costs, Software Quality, NSGA II, Maintenance Engineering, Computer Bugs, Java, Genetic Programming, Search Problems, Sociology, Statistics, Program Repair, Patch Generation, Genetic Programming, Multi Objective Optimization, Genetic Improvement"
Changeset-Based Topic Modeling of Software Repositories,"Abstract The standard approach to applying text retrieval models to code repositories is to train models on documents representing program elements. However, code changes lead to model obsolescence and to the need to retrain the model from the latest snapshot. To address this, we previously introduced an approach that trains a model on documents representing changesets from a repository and demonstrated its feasibility for feature location. In this paper, we expand our work by investigating: a second task (developer identification), the effects of including different changeset parts in the model, the repository characteristics that affect the accuracy of our approach, and the effects of the time invariance assumption on evaluation results. Our results demonstrate that our approach is as accurate as the standard approach for projects with most changes localized to a subset of the code, but less accurate when changes are highly distributed throughout the code. Moreover, our results demonstrate that context and messages are key to the accuracy of changeset-based models and that the time invariance assumption has a statistically significant effect on evaluation results, providing overly-optimistic results. Our findings indicate that our approach is a suitable alternative to the standard approach, providing comparable accuracy while eliminating retraining costs.Keywords Information Retrieval, Software Packages, Source Code Software, Text Analysis, Changeset Based Topic Modeling, Software Repositories, Text Retrieval Models, Code Repositories, Program Elements, Code Changes, Time Invariance Assumption, Changeset Based Models, Task Analysis, Standards, Feature Extraction, Resource Management, Software Maintenance, Maintenance Engineering, Changesets, Feature Location, Developer Identification, Program Comprehension, Mining Software Repositories, Online Topic Modeling"
Bridging Semantic Gaps between Natural Languages and APIs with Word Embedding,"Abstract Developers increasingly rely on text matching tools to analyze the relation between natural language words and APIs. However, semantic gaps, namely textual mismatches between words and APIs, negatively affect these tools. Previous studies have transformed words or APIs into low-dimensional vectors for matching; however, inaccurate results were obtained due to the failure of modeling words and APIs simultaneously. To resolve this problem, two main challenges are to be addressed: the acquisition of massive words and APIs for mining and the alignment of words and APIs for modeling. Therefore, this study proposes Word2API to effectively estimate relatedness of words and APIs. Word2API collects millions of commonly used words and APIs from code repositories to address the acquisition challenge. Then, a shuffling strategy is used to transform related words and APIs into tuples to address the alignment challenge. Using these tuples, Word2API models words and APIs simultaneously. Word2API outperforms baselines by 10-49.6 percent of relatedness estimation in terms of precision and NDCG. Word2API is also effective on solving typical software tasks, e.g., query expansion and API documents linking. A simple system with Word2API-expanded queries recommends up to 21.4 percent more related APIs for developers. Meanwhile, Word2API improves comparison algorithms by 7.9-17.4 percent in linking questions in Question&Answer communities to API documents.Keywords Application Program Interfaces, Computational Linguistics, Data Mining, Natural Language Processing, Pattern Matching, Query Processing, Text Analysis, Shuffling Strategy, Word Alignment, Mining, Textual Mismatches, Text Matching Tools, Word Embedding, Semantic Gaps, Natural Language Words, Word 2 API Expanded Queries, API Documents, Tools, Natural Languages, Training, Software, Task Analysis, Semantics, Estimation, Relatedness Estimation, Word Embedding, Word 2 Vec, Query Expansion, API Documents Linking"
Automating Intention Mining,"Abstract Developers frequently discuss aspects of the systems they are developing online. The comments they post to discussions form a rich information source about the system. Intention mining, a process introduced by Di Sorbo et al., classifies sentences in developer discussions to enable further analysis. As one example of use, intention mining has been used to help build various recommenders for software developers. The technique introduced by Di Sorbo et al. to categorize sentences is based on linguistic patterns derived from two projects. The limited number of data sources used in this earlier work introduces questions about the comprehensiveness of intention categories and whether the linguistic patterns used to identify the categories are generalizable to developer discussion recorded in other kinds of software artifacts (e.g., issue reports). To assess the comprehensiveness of the previously identified intention categories and the generalizability of the linguistic patterns for category identification, we manually created a new dataset, categorizing 5,408 sentences from issue reports of four projects in GitHub. Based on this manual effort, we refined the previous categories. We assess Di Sorbo et al.'s patterns on this dataset, finding that the accuracy rate achieved is low (0.31). To address the deficiencies of Di Sorbo et al.'s patterns, we propose and investigate a convolution neural network (CNN)-based approach to automatically classify sentences into different categories of intentions. Our approach optimizes CNN by integrating batch normalization to accelerate the training speed, and an automatic hyperparameter tuning approach to tune appropriate hyperparameters of CNN. Our approach achieves an accuracy of 0.84 on the new dataset, improving Di Sorbo et al.'s approach by 171 percent. We also apply our approach to improve an automated software engineering task, in which we use our proposed approach to rectify misclassified issue reports, thus reducing the bias introduced by such data to other studies. A case study on four open source projects with 2,076 issue reports shows that our approach achieves an average AUC score of 0.687, which improves other baselines by at least 16 percent.Keywords Computational Linguistics, Convolutional Neural Nets, Data Mining, Pattern Classification, Software Engineering, Intention Mining, Software Developers, Linguistic Patterns, Software Artifacts, Category Identification, CNN, Automatic Hyperparameter Tuning, Software Engineering, Convolution Neural Network, Sentence Classification, Taxonomy, Linguistics, Data Mining, Tuning, Computer Bugs, Software, Training, Deep Learning, Intention, Issue Report, Empirical Study"
Metamorphic Relations for Enhancing System Understanding and Use,"Abstract Modern information technology paradigms, such as online services and off-the-shelf products, often involve a wide variety of users with different or even conflicting objectives. Every software output may satisfy some users, but may also fail to satisfy others. Furthermore, users often do not know the internal working mechanisms of the systems. This situation is quite different from bespoke software, where developers and users typically know each other. This paper proposes an approach to help users to better understand the software that they use, and thereby more easily achieve their objectives-even when they do not fully understand how the system is implemented. Our approach borrows the concept of metamorphic relations from the field of metamorphic testing (MT), using it in an innovative way that extends beyond MT. We also propose a “symmetry” metamorphic relation pattern and a “change direction” metamorphic relation input pattern that can be used to derive multiple concrete metamorphic relations. Empirical studies reveal previously unknown failures in some of the most popular applications in the world, and show how our approach can help users to better understand and better use the systems. The empirical results provide strong evidence of the simplicity, applicability, and effectiveness of our methodology.Keywords Program Testing, Software Engineering, System Understanding, Software Output, Metamorphic Testing, MT, Symmetry Metamorphic Relation Pattern, Change Direction Metamorphic Relation Input Pattern, Multiple Concrete Metamorphic Relations, System Usage, Software Testing, Information Technology, Electronic Mail, Software Systems, Software Maintenance, Metamorphic Exploration, Symmetry, Metamorphic Testing, Metamorphic Relation, Metamorphic Relation Pattern, Metamorphic Relation Input Pattern, Change Direction, Oracle Problem, User Experience, User Countermeasure, Software Validation"
