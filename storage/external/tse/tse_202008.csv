title,abstract
How Practitioners Perceive Automated Bug Report Management Techniques,"Abstract Bug reports play an important role in the process of debugging and fixing bugs. To reduce the burden of bug report managers and facilitate the process of bug fixing, a great amount of software engineering research has been invested toward automated bug report management techniques. However, the verdict is still open whether such techniques are actually required and applicable outside the domain of theoretical research. To fill this gap, we conducted a survey among 327 practitioners to gain their insights into various categories of automated bug report management techniques. Specifically, we asked the respondents to rate the importance of such techniques and provide the rationale. To get deeper insights into practitioners' perspective, we conducted follow-up interviews with 25 interviewees selected from the survey respondents. Through the survey and the interviews, we gained a better understanding of the perceived usefulness (or its lack) of different categories of automated bug report management techniques. Based on our findings, we summarized some potential research directions in developing techniques to help developers better manage bug reports.Keywords Program Debugging, Software Engineering, Practitioner Perspective, Automated Bug Report Management Techniques, Software Engineering Research, Debugging, Bug Fixing, Computer Bugs, Software, Software Engineering, Bibliographies, Conferences, Interviews, Maintenance Engineering, Bug Report, Developer Perception"
"On the Nature of Merge Conflicts: A Study of 2,731 Open Source Java Projects Hosted by GitHub","Abstract When multiple developers change a software system in parallel, these concurrent changes need to be merged to all appear in the software being developed. Numerous merge techniques have been proposed to support this task, but none of them can fully automate the merge process. Indeed, it has been reported that as much as 10 to 20 percent of all merge attempts result in a merge conflict, meaning that a developer has to manually complete the merge. To date, we have little insight into the nature of these merge conflicts. What do they look like, in detail? How do developers resolve them? Do any patterns exist that might suggest new merge techniques that could reduce the manual effort? This paper contributes an in-depth study of the merge conflicts found in the histories of 2,731 open source Java projects. Seeded by the manual analysis of the histories of five projects, our automated analysis of all 2,731 projects: (1) characterizes the merge conflicts in terms of number of chunks, size, and programming language constructs involved, (2) classifies the manual resolution strategies that developers use to address these merge conflicts, and (3) analyzes the relationships between various characteristics of the merge conflicts and the chosen resolution strategies. Our results give rise to three primary recommendations for future merge techniques, that - when implemented - could on one hand help in automatically resolving certain types of conflicts and on the other hand provide the developer with tool-based assistance to more easily resolve other types of conflicts that cannot be automatically resolved.Keywords Java, Merging, Parallel Processing, Public Domain Software, Merge Conflicts, Open Source Java Projects, Git Hub, Software System, Parallel Software, Programming Language, Tools, History, Electronic Mail, Java, Software, Task Analysis, Software Merge, Merge Conflict, Merge Resolution"
The Adoption of JavaScript Linters in Practice: A Case Study on ESLint,"Abstract A linter is a static analysis tool that warns software developers about possible code errors or violations to coding standards. By using such a tool, errors can be surfaced early in the development process when they are cheaper to fix. For a linter to be successful, it is important to understand the needs and challenges of developers when using a linter. In this paper, we examine developers' perceptions on JavaScript linters. We study why and how developers use linters along with the challenges they face while using such tools. For this purpose we perform a case study on ESLint, the most popular JavaScript linter. We collect data with three different methods where we interviewed 15 developers from well-known open source projects, analyzed over 9,500 ESLint configuration files, and surveyed 337 developers from the JavaScript community. Our results provide practitioners with reasons for using linters in their JavaScript projects as well as several configuration strategies and their advantages. We also provide a list of linter rules that are often enabled and disabled, which can be interpreted as the most important rules to reason about when configuring linters. Finally, we propose several feature suggestions for tool makers and future work for researchers.Keywords Authoring Languages, Program Diagnostics, Linter Rules, Static Analysis Tool, Code Errors, Java Script Linters, ES Lint Configuration Files, Coding Standards, Tools, Static Analysis, Interviews, Encoding, Standards, Software, Face, Static Analysis Tools, Linters, Eslint, Javascript Linters, ASA Ts, Empirical Software Engineering"
Value-Flow-Based Demand-Driven Pointer Analysis for C and C++,"Abstract We present Supa, a value-flow-based demand-driven flow- and context-sensitive pointer analysis with strong updates for C and C++ programs. Supa enables computing points-to information via value-flow refinement, in environments with small time and memory budgets. We formulate Supa by solving a graph-reachability problem on an inter-procedural value-flow graph representing a program's def-use chains, which are pre-computed efficiently but over-approximately. To answer a client query (a request for a variable's points-to set), Supa reasons about the flow of values along the pre-computed def-use chains sparsely (rather than across all program points), by performing only the work necessary for the query (rather than analyzing the whole program). In particular, strong updates are performed to filter out spurious def-use chains through value-flow refinement as long as the total budget is not exhausted. We have implemented Supa on top of LLVM (4.0.0) together with a comprehensive micro-benchmark suite after a years-long effort (consisting of around 400 test cases, including hand-written ones and the ones extracted from real programs). We have evaluated Supa by choosing uninitialized pointer detection and C++ virtual table resolution as two major clients, using 24 real-world programs including 18 open-source C programs and 6 large CPU2000/2006 C++ benchmarks. For uninitialized pointer client, Supa achieves improved precision as the analysis budget increases, with its flow-sensitive (context-insensitive) analysis reaching 97.4 percent of that achieved by whole-program Sparse Flow-Sensitive analysis (SFS) by consuming about 0.18 seconds and 65 KB of memory per query, on average (with a budget of at most 10,000 value-flow edges per query). With context-sensitivity also considered, Supa becomes more precise for some programs but also incurs more analysis times. To further demonstrate the effectiveness of Supa, we have also evaluated Supa in resolving C++ virtual tables by querying the function pointers at every virtual callsite. Compared to analysis without strong updates for heap objects, Supa's demand-driven context-sensitive strong update analysis reduces 7.35 percent spurious virtual table targets with only 0.4 secs per query, on average.Keywords Data Flow Analysis, Data Structures, Flow Graphs, Object Oriented Programming, Optimising Compilers, Program Diagnostics, Reachability Analysis, Sensitivity Analysis, Value Flow Based Demand Driven Flow, Context Sensitive Pointer Analysis, Value Flow Refinement, Inter Procedural Value Flow Graph, Pre Computed Def Use Chains, Pointer Client, Sparse Flow Sensitive Analysis, Value Flow Based Demand Driven Pointer Analysis, Supa Demand Driven Context Sensitive Strong Update Analysis, C Program, Time 0 4 S, Memory Size 65 0 K Byte, Temperature 2006 0 C, Efficiency 97 4 Percent, Efficiency 7 35 Percent, C Languages, Resource Management, Open Source Software, Sensitivity, Reachability Analysis, Instruction Sets, Registers, Strong Updates, Value Flow, Pointer Analysis, Flow Sensitivity"
