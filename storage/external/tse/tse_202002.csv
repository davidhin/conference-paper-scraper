title,abstract
Motivation and Satisfaction of Software Engineers,"Abstract Context: The proper management of people can help software organisations to achieve higher levels of success. However, the limited attention paid to the appropriate use of theories to underpin the research in this area leaves it unclear how to deal with human aspects of software engineers, such as motivation and satisfaction. Objectives: This article aims to expose what drives the motivation and satisfaction of software engineers at work. Methods: A multiple case study was conducted at four software organisations in Brazil. For 11 months, data was collected using semi-structured interviews, diary studies, and document analyses. Results: The Theory of Motivation and Satisfaction of Software Engineers (TMS-SE), presented in this article, combines elements from well established theories with new findings, and translates them into the software engineering context. Conclusion: The TMS-SE advances the understanding of people management in the software engineering field and presents a strong conceptual framework for future investigations in this area.Keywords Human Factors, Human Resource Management, Organisational Aspects, Software Development Management, Software Organisations, Software Engineers, Software Engineering Context, Software Engineering Field, Theory Of Motivation And Satisfaction Of Software Engineers, People Management, Software Development Management, Software Engineering, Productivity, Organizational Aspects, Human Resource Management, Human Factors, Work Motivation, Job Satisfaction, Human Resource Management, Software Engineering"
Identifying Failure-Causing Schemas in the Presence of Multiple Faults,"Abstract Combinatorial testing (CT) has been proven effective in revealing the failures caused by the interaction of factors that affect the behavior of a system. The theory of Minimal Failure-Causing Schema (MFS) has been proposed to isolate the cause of a failure after CT. Most algorithms that aim to identify MFS focus on handling a single fault in the System Under Test (SUT). However, we argue that multiple faults are more common in practice, under which masking effects may be triggered so that some failures cannot be observed. The traditional MFS theory lacks a mechanism to handle such effects; hence, they may incorrectly isolate the MFS. To address this problem, we propose a new MFS model that takes into account multiple faults. We first formally analyze the impact of the multiple faults on existing MFS identifying algorithms, especially in situations where masking effects are triggered by multiple faults. We then develop an approach that can assist traditional algorithms to better handle multiple faults. Empirical studies were conducted using several kinds of open-source software, which showed that multiple faults with masking effects do negatively affect traditional MFS identifying approaches and that our approach can help to alleviate these effects.Keywords Fault Diagnosis, Program Testing, Software Fault Tolerance, Masking Effects, MFS Theory, Minimal Failure Causing Schema, Combinatorial Testing, CT, System Under Test, SUT, Open Source Software, Testing, Bars, Fault Diagnosis, Computer Bugs, Software Algorithms, Open Source Software, Software Testing, Combinatorial Testing, Failure Causing Schemas, Masking Effects"
An Integrated Approach for Effective Injection Vulnerability Analysis of Web Applications Through Security Slicing and Hybrid Constraint Solving,"Abstract Malicious users can attack Web applications by exploiting injection vulnerabilities in the source code. This work addresses the challenge of detecting injection vulnerabilities in the server-side code of Java Web applications in a scalable and effective way. We propose an integrated approach that seamlessly combines security slicing with hybrid constraint solving; the latter orchestrates automata-based solving with meta-heuristic search. We use static analysis to extract minimal program slices relevant to security from Web programs and to generate attack conditions. We then apply hybrid constraint solving to determine the satisfiability of attack conditions and thus detect vulnerabilities. The experimental results, using a benchmark comprising a set of diverse and representative Web applications/services as well as security benchmark applications, show that our approach (implemented in the JOACO tool) is significantly more effective at detecting injection vulnerabilities than state-of-the-art approaches, achieving 98 percent recall, without producing any false alarm. We also compared the constraint solving module of our approach with state-of-the-art constraint solvers, using six different benchmark suites; our approach correctly solved the highest number of constraints (665 out of 672), without producing any incorrect result, and was the one with the least number of time-out/failing cases. In both scenarios, the execution time was practically acceptable, given the offline nature of vulnerability detection.Keywords Constraint Handling, Internet, Java, Program Slicing, Search Problems, Security Of Data, Security Slicing, Hybrid Constraint Solving, Injection Vulnerabilities, Source Code, Java Web Applications, Minimal Program Slices, Web Programs, Attack Conditions, Security Benchmark Applications, Constraint Solving Module, Constraint Solvers, Vulnerability Detection, Injection Vulnerability Analysis, Efficiency 98 0 Percent, Security, Benchmark Testing, Tools, Explosions, Java, Static Analysis, Reliability, Vulnerability Detection, Constraint Solving, Static Analysis, Search Based Software Engineering"
Machine Learning-Based Prototyping of Graphical User Interfaces for Mobile Apps,"Abstract It is common practice for developers of user-facing software to transform a mock-up of a graphical user interface (GUI) into code. This process takes place both at an application's inception and in an evolutionary context as GUI changes keep pace with evolving features. Unfortunately, this practice is challenging and time-consuming. In this paper, we present an approach that automates this process by enabling accurate prototyping of GUIs via three tasks: detection, classification, and assembly. First, logical components of a GUI are detected from a mock-up artifact using either computer vision techniques or mock-up metadata. Then, software repository mining, automated dynamic analysis, and deep convolutional neural networks are utilized to accurately classify GUI-components into domain-specific types (e.g., toggle-button). Finally, a data-driven, K-nearest-neighbors algorithm generates a suitable hierarchical GUI structure from which a prototype application can be automatically assembled. We implemented this approach for Android in a system called ReDraw. Our evaluation illustrates that ReDraw achieves an average GUI-component classification accuracy of 91 percent and assembles prototype applications that closely mirror target mock-ups in terms of visual affinity while exhibiting reasonable code structure. Interviews with industrial practitioners illustrate ReDraw's potential to improve real development workflows.Keywords Computer Vision, Data Mining, Graphical User Interfaces, Image Classification, Learning Artificial Intelligence, Mobile Computing, Neural Nets, Program Testing, Prototype Application, GUI Component Classification Accuracy, Assembles Prototype Applications, Target Mock Ups, Reasonable Code Structure, Machine Learning Based Prototyping, Graphical User Interface, Mobile Applications, User Facing Software, Evolutionary Context, GUI Changes, Logical Components, Computer Vision Techniques, Software Repository Mining, Automated Dynamic Analysis, Deep Convolutional Neural Networks, Hierarchical GUI Structure, Graphical User Interfaces, Software, Task Analysis, Prototypes, Metadata, Androids, Humanoid Robots, GUI, CNN, Mobile, Prototyping, Machine Learning, Mining Software Repositories"
