title,abstract
Tell You a Definite Answer: Whether Your Data is Tainted During Thread Scheduling,"Abstract With the advent of multicore processors, there is a great need to write parallel programs to take advantage of parallel computing resources. However, due to the nondeterminism of parallel execution, the malware behaviors sensitive to thread scheduling are extremely difficult to detect. Dynamic taint analysis is widely used in security problems. By serializing a multithreaded execution and then propagating taint tags along the serialized schedule, existing dynamic taint analysis techniques lead to under-tainting with respect to other possible interleavings under the same input. In this paper, we propose an approach called DSTAM that integrates symbolic analysis and guided execution to systematically detect tainted instances on all possible executions under a given input. Symbolic analysis infers alternative interleavings of an executed trace that cover new tainted instances, and computes thread schedules that guide future executions. Guided execution explores new execution traces that drive future symbolic analysis. We have implemented a prototype as part of an educational tool that teaches secure C programming, where accuracy is more critical than efficiency. To the best of our knowledge, DSTAM is the first algorithm that addresses the challenge of taint analysis for multithreaded program under fixed inputs.Keywords Invasive Software, Microprocessor Chips, Multiprocessing Systems, Multi Threading, Parallel Programming, Program Diagnostics, Scheduling, Tainted Instances, Thread Schedules, Guide Future Executions, Drive Future Symbolic Analysis, Secure C Programming, DSTAM, Multithreaded Program, Definite Answer, Thread Scheduling, Multicore Processors, Parallel Programs, Parallel Computing Resources, Parallel Execution, Security Problems, Multithreaded Execution, Taint Tags, Serialized Schedule, Dynamic Taint Analysis Techniques, Alternative Interleavings, Executed Trace, Instruction Sets, Security, Tools, Monitoring, Schedules, Prototypes, Taint Analysis, Multithreaded Programs, Symbolic Analysis, Encoding, Guided Execution"
Uncovering the Periphery: A Qualitative Survey of Episodic Volunteering in Free/Libre and Open Source Software Communities,
An Interactive and Dynamic Search-Based Approach to Software Refactoring Recommendations,"Abstract Successful software products evolve through a process of continual change. However, this process may weaken the design of the software and make it unnecessarily complex, leading to significantly reduced productivity and increased fault-proneness. Refactoring improves the software design while preserving overall functionality and behavior, and is an important technique in managing the growing complexity of software systems. Most of the existing work on software refactoring uses either an entirely manual or a fully automated approach. Manual refactoring is time-consuming, error-prone and unsuitable for large-scale, radical refactoring. On the other hand, fully automated refactoring yields a static list of refactorings which, when applied, leads to a new and often hard to comprehend design. Furthermore, it is difficult to merge these refactorings with other changes performed in parallel by developers. In this paper, we propose a refactoring recommendation approach that dynamically adapts and interactively suggests refactorings to developers and takes their feedback into consideration. Our approach uses NSGA-II to find a set of good refactoring solutions that improve software quality while minimizing the deviation from the initial design. These refactoring solutions are then analyzed to extract interesting common features between them such as the frequently occurring refactorings in the best non-dominated solutions. Based on this analysis, the refactorings are ranked and suggested to the developer in an interactive fashion as a sequence of transformations. The developer can approve, modify or reject each of the recommended refactorings, and this feedback is then used to update the proposed rankings of recommended refactorings. After a number of introduced code changes and interactions with the developer, the interactive NSGA-II algorithm is executed again on the new modified system to repair the set of refactoring solutions based on the new changes and the feedback received from the developer. We evaluated our approach on a set of eight open source systems and two industrial projects provided by an industrial partner. Statistical analysis of our experiments shows that our dynamic interactive refactoring approach performed significantly better than four existing search-based refactoring techniques and one fully-automated refactoring tool not based on heuristic search.Keywords Genetic Algorithms, Search Problems, Software Maintenance, Software Quality, Software Tools, Statistical Analysis, Software Refactoring Recommendations, Software Products, Software Design, Software Systems, Manual Refactoring, Software Quality, Dynamic Interactive Refactoring Approach, Search Based Refactoring, Interactive Search Based Approach, Dynamic Search Based Approach, Interactive NSGA II Algorithm, Statistical Analysis, Manuals, Tools, Software Quality, Maintenance Engineering, Optimization, Electronic Mail, Search Based Software Engineering, Refactoring, Interactive Optimization, Software Quality"
Large-Scale Third-Party Library Detection in Android Markets,
Automatic Detection and Repair Recommendation of Directive Defects in Java API Documentation,"Abstract Application Programming Interfaces (APIs) represent key tools for software developers to build complex software systems. However, several studies have revealed that even major API providers tend to have incomplete or inconsistent API documentation. This can severely hamper the API comprehension and, as a consequence, the quality of the software built on them. In this paper, we propose DRONE (Detect and Repair of dOcumentatioN dEfects), a framework to automatically detect and repair defects from API documents by leveraging techniques from program analysis, natural language processing, and constraint solving. Specifically, we target at the directives of API documents, which are related to parameter constraints and exception handling declarations. Furthermore, in presence of defects, we also provide a prototypical repair recommendation system. We evaluate our approach on parts of the well-documented APIs of JDK 1.8 APIs (including javaFX) and Android 7.0 (level 24). Across the two empirical studies, our approach can detect API defects with an average F-measure of 79.9, 71.7, and 81.4 percent, respectively. The API repairing capability has also been evaluated on the generated recommendations in a further experiment. User judgments indicate that the constraint information is addressed correctly and concisely in the rendered directives.Keywords Android Operating System, Application Program Interfaces, Java, Natural Language Processing, Software Libraries, System Documentation, Application Programming Interfaces, Software Developers, Complex Software Systems, API Providers, Incomplete API Documentation, Inconsistent API Documentation, API Comprehension, Repair Defects, API Documents, Program Analysis, Prototypical Repair Recommendation System, API Repairing Capability, Automatic Detection, Directive Defects, Java API Documentation, API Defects, Documentation Defects, JDK 1 8 API, Java FX, Android 7 0, Documentation, Maintenance Engineering, Software, Drones, Androids, Humanoid Robots, Facebook, API Documentation, Directive Defects, Natural Language Processing, Repair Recommendation"
Corrections to “Automatic and Accurate Expansion of Abbreviations in Parameters”,"Abstract Presents corrections to author information in the above named paper.     In [1], the author affiliation for Yanjie Jiang, Hui Liu, and Jiaqi Zhu should be “the Beijing Institute of Technology.” References  [1]Y. Jiang, H. Liu, J. Zhu, and L. Zhang, “Automatic and accurate expansion of abbreviations in parameters, “ IEEE Trans. Softw. Eng., vol. 46, no. 7, pp. 732–747, Jul.2020.Keywords Computer Science, Software"
How Do Users Revise Answers on Technical Q&A Websites? A Case Study on Stack Overflow,"Abstract To ensure the quality of its shared knowledge, Stack Overflow encourages users to revise answers through a badge system, which is based on quantitative measures (e.g., a badge is awarded after revising more than 500 answers). Prior studies show that badges can positively steer the user behavior on Stack Overflow (e.g., increasing user participation). However, little is known whether revision-related badges have a negative impact on the quality of revisions since some studies show that certain users may game incentive systems to gain rewards. In this study, we analyze 3,871,966 revision records that are collected from 2,377,692 Stack Overflow answers. We find that: 1) Users performed a much larger than usual revisions on the badge-awarding days compared to normal days; 25% of the users did not make any more revisions once they received their first revision-related badge. 2) Performing more revisions than usual in a single day increased the likelihood of such revisions being rolled back (e.g., due to undesired or incorrect revisions). 3) Users were more likely to perform text and small revisions if they performed many revisions in a single day. Our findings are concurred by the Stack Overflow community, and they highlight the need for changes to the current badge system in order to provide a better balance between the quality and quantity of revisions.Keywords Question Answering Information Retrieval, Software Engineering, Web Sites, User Behavior, User Participation, Revision Related Badge, Stack Overflow Answers, Usual Revisions, Badge Awarding Days, Undesired Revisions, Incorrect Revisions, Stack Overflow Community, Current Badge System, Revision Records, Atmospheric Measurements, Particle Measurements, Games, Indexes, Knowledge Engineering, Software, Computer Science, Stack Overflow, Incentive System, Badge, Answer Revision"
