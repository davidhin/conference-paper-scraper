title,abstract
Research article - Do android developers neglect error handling? a maintenance-Centric study on the relationship between android abstractions and uncaught exceptions,"AbstractAll the mainstream programming languages in widespread use for mobile app development provide error handling mechanisms to support the implementation of robust apps. Android apps, in particular, are usually written in the Java programming language. Java includes an exception handling mechanism that allows programs to signal the occurrence of errors by throwing exceptions and to handle these exceptions by catching them. All the Android-specific abstractions, such as activities and asynctasks, can throw exceptions when errors occur. When an app catches the exceptions that it or the libraries upon which it depends throw, it can resume its activity or, at least, fail in a graceful way. On the other hand, uncaught exceptions can lead an app to crash, particularly if they occur within the main thread. Previous work has shown that, in real Android apps available at the Play Store, uncaught exceptions thrown by Android-specific abstractions often cause these apps to fail.This paper presents an empirical study on the relationship between the usage of Android abstractions and uncaught exceptions. Our approach is quantitative and maintenance-centric. We analyzed changes to both normal and exception handling code in 112 versions extracted from 16 software projects covering a number of domains, amounting to more than 3 million LOC. Change impact analysis and exception flow analysis were performed on those versions of the projects. The main finding of this study is that, during the evolution of the analyzed apps, an increase in the use of Android abstractions exhibits a positive and statistically significant correlation with the number of uncaught exception flows. Since uncaught exceptions cause apps to crash, this result suggests that these apps are becoming potentially less robust as a consequence of exception handling misuse. Analysis of multiple versions of these apps revealed that Android developers usually employ abstractions that may throw exceptions without adding the appropriate handlers for these exceptions. This study highlights the need for better testing and verification tools with a focus on exception handling code and for a change of culture in Android development or, at least, in the design of its APIs."
Research article - Monitoring self-adaptive applications within edge computing frameworks: A state-of-the-art review,"AbstractRecently, a promising trend has evolved from previous centralized computation to decentralized edge computing in the proximity of end-users to provide cloud applications. To ensure the Quality of Service (QoS) of such applications and Quality of Experience (QoE) for the end-users, it is necessary to employ a comprehensive monitoring approach. Requirement analysis is a key software engineering task in the whole lifecycle of applications; however, the requirements for monitoring systems within edge computing scenarios are not yet fully established. The goal of the present survey study is therefore threefold: to identify the main challenges in the field of monitoring edge computing applications that are as yet not fully solved; to present a new taxonomy of monitoring requirements for adaptive applications orchestrated upon edge computing frameworks; and to discuss and compare the use of widely-used cloud monitoring technologies to assure the performance of these applications. Our analysis shows that none of existing widely-used cloud monitoring tools yet provides an integrated monitoring solution within edge computing frameworks. Moreover, some monitoring requirements have not been thoroughly met by any of them."
Research article - FPA-FL: Incorporating static fault-proneness analysis into statistical fault localization,"AbstractDespite the proven applicability of the statistical methods in automatic fault localization, these approaches are biased by data collected from different executions of the program. This biasness could result in unstable statistical models which may vary dependent on test data provided for trial executions of the program. To resolve the difficulty, in this article a new ‘fault-proneness’-aware statistical approach based on Elastic-Net regression, namely FPA-FL is proposed. The main idea behind FPA-FL is to consider the static structure and the fault-proneness of the program statements in addition to their dynamic correlations with the program termination state. The grouping effect of FPA-FL is helpful for finding multiple faults and supporting scalability. To provide the context of failure, cause-effect chains of program faults are discovered. FPA-FL is evaluated from different viewpoints on well-known test suites. The results reveal high fault localization performance of our approach, compared with similar techniques in the literature."
Research article - Broadcast tree construction framework in tactile internet via dynamic algorithm,"AbstractExtremely low-latency and real-time communications are required in Tactile Internet to transfer physical tactile experiences remotely. In addition, its traffic has stringent requirements on bandwidth and quality of service (QoS). To minimize total costs of establishing the network and satisfy a pre-defined global upper delay-bound on the paths from the server to any other client for message broadcast in Tactile Internet, this paper presents a Rooted Delay-Constrained Minimum Spanning Tree (RDCMST) construction framework based on dynamic algorithm. The network is modeled as a connected weighted and undirected graph. Infeasible and suboptimal edges are discarded first by preprocessing techniques to reduce the processing complexity of the algorithm. Then the edges of the graph are processed based on a dynamic graph algorithm, which can maintain a single-source shortest path tree for the online edge deletions, such that total costs can be minimized while ensuring the delay-constraint and the tree structure. Experimental results show that our proposed approach greatly outperforms existing competing RDCMST formation algorithms, in terms of both average cost and stability of solutions."
Research article - On the implementation of dynamic software product lines: An exploratory study,"AbstractDynamic Software Product Line (DSPL) engineering is a paradigm aimed at handling adaptations at runtime. An inherent challenge in DSPL engineering is to reduce the design complexity of adaptable software, particularly in terms of evolution. Existing research only recently started to investigate evolution in this field, but does not assess the impact of different implementations under software quality in evolutionary scenarios. This work presents a characterization of thirteen dynamic variability mechanisms. Based on such characterization, we implemented a DSPL using Object-oriented Programming (OOP) mechanisms. From this implementation, we evidenced that DSPL requires changes and extensions to design, in terms of functionality and adaptation capabilities. Since Aspect-oriented Programming (AOP) was well ranked according to characterization and some studies have demonstrated the likely synergies between AOP and DSPL, we decided to compare it with OOP. We empirically evaluated how OOP and AOP could affect source code quality from the viewpoint of an evolving DSPL. As a result, AOP yields better results in terms of size, SoC, cohesion, and coupling measures. Conversely, AOP provides lower change propagation impact. Although the packages in AOP were more susceptible to changes than in OOP, we could indicate that AOP may be a feasible strategy for DSPL implementation."
Research article - AQUArIUM - A suite of software measures for HCI quality evaluation of ubiquitous mobile applications,"AbstractUbiquitous computing has changed the way users interact with technology. Its applications are everywhere, supporting users in everyday activities in a transparent way with little or no need for attention. To ensure the adoption of these applications, it is essential to assess the quality of the interaction with its users. To do that, measurements can be applied to obtain data about quality characteristics in a software product. In a previous study about quality characteristics and software measures for ubiquitous computing, we have identified a gap in the literature regarding software measures for evaluating essential quality characteristics in ubiquitous systems. Therefore, this paper proposes a suite of well-defined software measures (twenty-four in total), called AQUArIUM, to evaluate human-computer interaction (HCI) in ubiquitous applications for mobile devices. These measures address five quality characteristics of ubiquitous computing: Context-awareness, Mobility, Attention, Calmness and Transparency. The proposed suite was validated theoretically and empirically. The results showed not only that the suite is feasible, but also that it indicates specific problems of HCI quality, which are helpful in improving the evaluated ubiquitous mobile application."
Research article - A replicated experiment for evaluating the effectiveness of pairing practice in PSP education,"AbstractBackground: Handling large-sized classes is one of the major challenges in Personal Software Process (PSP) education in a tertiary education environment. We applied a pairing approach in PSP education and managed to mitigate the size challenge without sacrificing education effectiveness, which has been verified in an experiment in 2010 (PSP2010). However, there are several issues (e.g., mutual interference among student pairs, confusing evaluation comments, untraceable corrections, etc.) existing in this experiment, which may create mist towards proper understanding of the education approach.Objective: In order to address the identified issues and better understand both pros and cons of the pairing approach, we replicated the experiment in 2014.Method: With new lab arrangement and evaluation mechanism devised, the replication (PSP2014) involved 120 students after their first academic year, who were separated into two groups with 40 pairs of students in one group and 40 solo students in the other.Results: Results of the replication include: 1) paired students conformed process discipline no worse (sometime better) than solo students; 2) paired students performed better than solo students in the final exam; 3) both groups spent comparable amount of time in preparing submissions; 4) both groups performed similar in size estimation and time estimation of the course assignments; 5) the quality of the programs developed by paired students is no less (sometime better) than solo students.Conclusion: The replication together with the original study confirms that, as an education approach, the pairing practice could reduce the amount of submissions required in a PSP training without sacrificing (sometime improving) the education effectiveness."
Research article - An experimental replication on the effect of the practice of mindfulness in conceptual modeling performance,"AbstractContext: Mindfulness is a meditation technique aimed to increase clearness of mind and awareness. In the 2013–2014 academic year, an experiment was carried out to test whether the practice of mindfulness during 4 weeks improved or not the conceptual modeling performance using UML class diagrams of 32 second–year students of Software Engineering at the University of Seville.Objective: An internal replication with some changes in the original design was performed in the first semester of the 2014–2015 academic year in order to confirm the insights provided by the original study and increase the confidence in its conclusions. The sample were 53 students with the same profile than in the original study.Method: Half the students (27 subjects) practiced mindfulness during 6 weeks, while the other half (26 subjects), i.e. the control group, received no treatment during that time. All the students developed two conceptual models using UML class diagrams from a transcript of an interview, one before and another after the 6 weeks of mindfulness sessions, and the results were compared in terms of conceptual modeling effectiveness and efficiency.Results: The results of both experiments were similar, showing that the practice of mindfulness significantly improves conceptual modeling efficiency. Regarding conceptual modeling effectiveness, an improvement is observed in practice, but the analysis shows that such improvement is not statistically significant. After a reanalysis of data, consistent results have also been obtained.Conclusion: After a replication that leads to the same conclusions as the original study, the adequacy of the original experiment is confirmed and the credibility of its results is increased. Thus, we can state that the practice of mindfulness can improve the efficiency of Software Engineering students in the development of conceptual models, although further experimentation is needed in order to confirm the results in other contexts and other Software Engineering activities different from conceptual modeling."
Research article - Predicting bug-fixing time: A replication study using an open source software project,"AbstractBackground: On projects with tight schedules and limited budgets, it may not be possible to resolve all known bugs before the next release. Estimates of the time required to fix known bugs (the “bug fixing time”) would assist managers in allocating bug fixing resources when faced with a high volume of bug reports.Aim: In this work, we aim to replicate a model for predicting bug fixing time with open source data from Bugzilla Firefox.Method: To perform the replication study, we follow the replication guidelines put forth by Carver [J. C. Carver, Towards reporting guidelines for experimental replications: a proposal, in: 1st International Workshop on Replication in Empirical Software Engineering, 2010.]. Similar to the original study, we apply a Markov-based model to predict the number of bugs that can be fixed monthly. In addition, we employ Monte-Carlo simulation to predict the total fixing time for a given number of bugs. We then use the k-nearest neighbors algorithm to classify fixing times into slow and fast.Result: The results of the replicated study on Firefox are consistent with those of the original study. The results show that there are similarities in the bug handling behaviour of both systems.Conclusion: We conclude that the model that estimates the bug fixing time is robust enough to be generalized, and we can rely on this model for our future research."
Research article - Automated inference of likely metamorphic relations for model transformations,"AbstractModel transformations play a cornerstone role in Model-Driven Engineering (MDE) as they provide the essential mechanisms for manipulating and transforming models. Checking whether the output of a model transformation is correct is a manual and error-prone task, referred to as the oracle problem. Metamorphic testing alleviates the oracle problem by exploiting the relations among different inputs and outputs of the program under test, so-called metamorphic relations (MRs). One of the main challenges in metamorphic testing is the automated inference of likely MRs.This paper proposes an approach to automatically infer likely MRs for ATL model transformations, where the tester does not need to have any knowledge of the transformation. The inferred MRs aim at detecting faults in model transformations in three application scenarios, namely regression testing, incremental transformations and migrations among transformation languages. In the experiments performed, the inferred likely MRs have proved to be quite accurate, with a precision of 96.4% from a total of 4101 true positives out of 4254 MRs inferred. Furthermore, they have been useful for identifying mutants in regression testing scenarios, with a mutation score of 93.3%. Finally, our approach can be used in conjunction with current approaches for the automatic generation of test cases."
Research article - Contract-based testing for PHP with Praspel,"AbstractWe summarize several contributions related to the PHP Realistic Annotation and SPEcification Language (Praspel). This language extends PHP programs with annotations for the formal specification of the behavior of their functions and for the declaration of types for their data. These contracts are used to automate test generation, by deriving test cases and test data, and test execution, by checking assertions at run-time in order to establish the test verdict. Our approach to contract-based testing for PHP is fully implemented into a PHP framework currently in use by several web companies."
Research article - Temporal algebraic query of test sequences,"AbstractNowadays tools can generate test suites consisting of large number of test sequences. The used algorithms are typically random-based. Although more advanced variations may incorporate an advanced search algorithm to cover difficult scenarios, many decisions still have to be made randomly simply because no information is available to calculate the best decision. Because of this, many of the generated sequences may be redundant, while some others may be rare and hard to get. This paper presents a rich formalism that is based on a mix of algebraic relations and Linear Temporal Logic (LTL) to query test suites, and an efficient algorithm to execute such queries. Queries can be used as correctness specifications (oracles) to validate a test suite. They are however more general as they can be used to filter out test sequences with interesting properties, e.g. to archive them for future use. The proposed formalism is quite expressive: it can express algebraic equations with logical variables, Hoare triples, class invariants, as well as their temporal modalities. An evaluation of the query algorithm’s performance is included in this paper. The whole query framework has been implemented in a testing tool for Java called T3i."
Research article - Stateless techniques for generating global and local test oracles for message-passing concurrent programs,"AbstractA test oracle for a concurrent program is a method for checking whether an observed behavior of the program is consistent with the program's specification. Abstract specification models for message-passing concurrent programs are often expressed as, or can be translated into, a labeled transition system (LTS). Stateful techniques for generating test oracles from LTS specification models are often limited by the state explosion problem. In this paper, we present a stateless technique for generating global and local test oracles from LTS specification models. A global test oracle uses tests generated from a global LTS model of the complete system to verify a global implementation relation between the model of the system and its implementation. Global test oracles, however, may require too many test sequences to be executed by the implementation. A local test oracle verifies local implementation relations between individual component models and their implementation threads. Local tests are executed against individual threads, without testing the system as a whole. Verifying the local implementation relations implies that a corresponding global implementation relation holds between the complete system model and its implementation. Empirical results indicate that using local test oracles can significantly reduce the number of executed test sequences."
Research article - VISOR: A fast image processing pipeline with scaling and translation invariance for test oracle automation of visual output systems,"AbstractTest oracles differentiate between the correct and incorrect system behavior. Hence, test oracle automation is essential to achieve overall test automation. Otherwise, testers have to manually check the system behavior for all test cases. A common test oracle automation approach for testing systems with visual output is based on exact matching between a snapshot of the observed output and a previously taken reference image. However, images can be subject to scaling and translation variations. These variations lead to a high number of false positives, where an error is reported due to a mismatch between the compared images although an error does not exist. To address this problem, we introduce an automated test oracle, named VISOR, that employs a fast image processing pipeline. This pipeline includes a series of image filters that align the compared images and remove noise to eliminate differences caused by scaling and translation. We evaluated our approach in the context of an industrial case study for regression testing of Digital TVs. Results show that VISOR can avoid 90% of false positive cases after training the system for 4 h. Following this one-time training, VISOR can compare thousands of image pairs within seconds on a laptop computer."
Research article - Exploring the usefulness of unlabelled test cases in software fault localization,"AbstractIn automatic software fault localization techniques, both the coverage and the testing outcomes of the provided test suite are considered to be essential information. The problem occurs when test oracles do not exist. Specifically, the test suite will contain a large number of unlabelled test cases, i.e., test cases whose output is not identified as being either correct (passing) or incorrect (failing). Such unlabelled test cases cannot be directly used, thereby leading to a degradation of localization effectiveness. In this paper, we propose an approach based on test classification to enable the use of unlabelled test cases in localizing faults. In our approach, unlabelled test cases are classified based on their execution information and are then assigned corresponding estimated labels to allow them to be utilized in fault localization. Experimental results show that with the utilization of these newly labelled test cases, the effectiveness of fault localization can indeed be improved."
